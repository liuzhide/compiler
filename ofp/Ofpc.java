/**
 * Assignment2StarterCode.java
 * September 20, 2020
 */
//package yourLNUaccount.4dv507.a2;

// Remember to include the ANTLR JAR file to the classpath for your project!
import java.io.*;
import org.antlr.v4.gui.Trees;
import org.antlr.v4.runtime.*;
import org.antlr.v4.runtime.tree.*;



/**
 * @author Kostiantyn Kucher
 *
 * Note: the class in your implementation should be called "Main" (or similar) instead,
 * and it should be a part of a properly titled package, e.g., "yourLNUaccount.4dv507.a2"
 */
public class Ofpc {

    public static void main(String[] args) throws Exception {
	// Read the input program file; preferably, use the command-line argument
	// provided by the user! (String args[] in main() for Java)
	// Avoiding a hardcoded path specific to your machine is a good practice...
	if (args.length < 1) {
	    System.err.println("Input file not provided!");
	    System.exit(1);
	}
		
	// E.g., the user could eventually start this program from the command line as
	// "java -cp lib/*:bin Assignment2StarterCode tests-valid/arithmetic.ofp"
	// and the input path would thus be "tests-valid/arithmetic.ofp"
	String inputPath = args[0];
		
	// Parse the input program
	System.out.println("\nParsing started for " + inputPath);
		
	// Use the parser and lexer previously generated by ANTLR for the .g4 file
	// Note: the titles of some classes below will depend on
	// the titles used in your ANTLR grammar file!
		
	OfpParser parser = null;
	OfpParser.ProgramContext root = null;
		
	// Read and parse the input program while keeping track of parsing errors
	ConsoleErrorListener errorListener = new ConsoleErrorListener();
	try {
	    CharStream inputStream = CharStreams.fromFileName(inputPath);
	    OfpLexer lexer = new OfpLexer(inputStream);
	    parser = new OfpParser(new BufferedTokenStream(lexer));
	    parser.addErrorListener(errorListener);
	    root = parser.program(); // "program" is the start rule in the .g4 grammar
	} catch (IOException e) {
	    e.printStackTrace();
	}

	// Instead of using the existing ConsoleErrorListener,
	// you could implement your own custom subclass of
	// org.antlr.v4.runtime.BaseErrorListener
	// and count the number of reported parsing errors
	// (e.g., if the count > 0, abort compilation and exit)
		
	// Optionally, display the parse tree for the input program:
	//Trees.inspect(root, parser);
		
	int semanticErrorCount = 0;
	// TODO: Symbol table construction using a listener ...
	ParseTreeWalker walker = new ParseTreeWalker();
	PopSymbolTable popListener = new PopSymbolTable();
	walker.walk(popListener, root);
	semanticErrorCount += popListener.getErrorCount();
	// TODO: Symbol reference checking using a listener ...
	VariableCheck varCheckListener = new VariableCheck(popListener.getSymbolTable());
	walker.walk(varCheckListener, root);
	semanticErrorCount += varCheckListener.getErrorCount();
	// TODO: Type checking using a visitor ...
	TypeCheck typeCheckVisitor = new TypeCheck(popListener.getSymbolTable());
	typeCheckVisitor.visit(root);
	// Update the counter of semantic errors after each of the steps above
	semanticErrorCount += typeCheckVisitor.getErrorCount();
		
	System.out.println("Total semantic error count: " + semanticErrorCount);
	if (semanticErrorCount > 0) {
	    System.err.println("\nSemantic errors discovered - Exit!");
	    System.exit(-1);
	}
		
	// After this stage, the input program is expected to be valid!
	ByteCodeGenerator jGen = new ByteCodeGenerator(popListener.getSymbolTable(),typeCheckVisitor.getTypes());
	jGen.visit(root);
	/*PythonCodeGenerator pyGen = new PythonCodeGenerator(popListener.getSymbolTable());
	  String pyProgram = pyGen.visit(root);
	  // inputPath == args[0]
	  String pyOutputPath = inputPath.replaceAll("\\.ofp$", ".py");
	  try {
	  PrintWriter pw = new PrintWriter(pyOutputPath);
	  pw.print(pyProgram);
	  pw.close();
	  } catch (IOException e) {
	  e.printStackTrace();
	  }*/
	/*System.out.println("\nPython program saved as: "+pyOutputPath);
	  File writename = new File("/home/liuzhide/d/output.txt");
	  writename.createNewFile(); 
	  FileWriter writer = new FileWriter(writename , true);//参数：一个第一步的参数file和一个true可读写属性值
	  BufferedWriter out = new BufferedWriter(writer);  
	  out.write("BSS-hello world\r\n");
	  out.flush();
	  out.close();*/

    }

}
